{"meta":{"title":"考拉动效","subtitle":"考拉前端团队 KAOLA-FED","description":"考拉前端团队动效展示网页","author":"KAOLA FED","url":"https://motionvisions.github.io"},"pages":[{"title":"about","date":"2016-12-06T09:20:50.000Z","updated":"2016-12-06T20:20:10.000Z","comments":true,"path":"about/index.html","permalink":"https://motionvisions.github.io/about/index.html","excerpt":"","text":"Welcome to visit."}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2016-12-06T20:20:10.000Z","updated":"2016-12-07T01:40:03.000Z","comments":true,"path":"2016/12/07/hello-world/","link":"","permalink":"https://motionvisions.github.io/2016/12/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Quick StartCreate a new postCreate a new postCreate a new postQuick StartCreate a new postCreate a new postCreate a new post","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://motionvisions.github.io/categories/技术文章/"}],"tags":[{"name":"ADFA tags tags","slug":"ADFA-tags-tags","permalink":"https://motionvisions.github.io/tags/ADFA-tags-tags/"}]},{"title":"Canvas上绘制动画","slug":"Canvas上绘制动画","date":"2016-12-01T16:00:00.000Z","updated":"2016-12-09T03:43:13.000Z","comments":true,"path":"2016/12/02/Canvas上绘制动画/","link":"","permalink":"https://motionvisions.github.io/2016/12/02/Canvas上绘制动画/","excerpt":"","text":"Canvas上绘制精灵图的一帧我们知道我们需要调用drawImage 在画布上去绘制一个图片，那如果我们要绘制一个动图我们需要如何实现呢？我们要获取精灵图片对应的那一帧，然后在画布上绘制。每次绘制一帧，我们需要先清空原先画布上的内容 1void ctx.drawImage(iamge. sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 注意: sx,sy 是指源精灵图片获取的位置， dx,dy 指的是在画布上需要对应的位置，所以我们写一个Sprite 类，这个类一般要描述下面这些信息 12345678910111213141516171819202122232425262728293031323334var bird_opt = &#123; image: image, startX: 100, //绘制的起始坐标X startY: 100, //绘制的起始坐标Y rect: &#123;x:0,y:0,w:86,h:60&#125;, frames: [ //精灵动画每一帧的相关信息 &#123;x:0,y:0,w:86,h:60&#125;, &#123;x:0,y:60,w:86,h:60&#125;, &#123;x:0,y:120,w:86,h:60&#125; ] &#125;;function Sprite(opt)&#123; var sprite_proto = &#123;&#125;; sprite_proto.current_frame_index = 0; sprite_proto.image = opt.image; sprite_proto.rect = opt.rect; sprite_proto.frames = opt.frames; sprite_proto.startX = opt.startX; sprite_proto.startY = opt.startY; sprite_proto.getNextFrame = function()&#123; var curFrame = this.frames[this.current_frame_index]; this.current_frame_index++; if(this.current_frame_index == this.frames.length) this.current_frame_index = 0; return curFrame; &#125; return sprite_proto; &#125; 我们再创建一个绘制画布类DrawCanvas, 主要需要两个方法，一个是renderFrame（绘制精灵的某帧）, 一个是清空画布clear 12345678910111213141516171819202122232425function DrawCanvas(opt)&#123; this.context = opt.context; this.width = opt.width; this.height = opt.height; &#125; DrawCanvas.prototype.renderFrame = function(sprite)&#123; var frame = sprite.getNextFrame(); this.context.drawImage( sprite.image, frame.x, frame.y, frame.w, frame.h, sprite.startX, sprite.startY, sprite.rect.w, sprite.rect.h ); &#125; DrawCanvas.prototype.clear = function()&#123; this.context.clearRect(0,0,this.width, this.height); &#125; 结合上面两个类，我们就可以再画布上先绘制精灵图的第一帧 1234567891011121314151617181920212223242526var image = new Image(); image.src = '/images/bird.png'; image.onload = function()&#123; var bird_opt = &#123; image: image, startX: 100, startY: 100, rect: &#123;x:0,y:0,w:86,h:60&#125;, frames: [ &#123;x:0,y:0,w:86,h:60&#125;, &#123;x:0,y:60,w:86,h:60&#125;, &#123;x:0,y:120,w:86,h:60&#125; ] &#125;, birdSprite = Sprite(bird_opt), canvas = document.getElementById('canvas'), canvas_opt = &#123; context: canvas.getContext('2d'), width:canvas.width, height:canvas.height &#125;; var myCanvas = new DrawCanvas(canvas_opt); myCanvas.renderFrame(birdSprite); &#125;; Canvas 上让精灵图动起来我们需要绘制我们的精灵图，那么我们需要setInterval清空我们的画布，绘制对应帧数的图片。 1234567//canvas上动画的绘制是通过计时器去实现的 setInterval(function()&#123; myCanvas.clear(); myCanvas.renderFrame(birdSprite); &#125;, 200);//但其实做动画的最佳循环是使用requestAnimationFrame,所以我们换种写法 注意：我们创建我们的sprite之前我们需要预先将我们使用的图片下载完，所以我们需要 12345var image = new Image();image.src = '/images/bird.png';image.onload = function()&#123; .....&#125; 所以在下一篇文章里我们会看到相关框架里面会实现preload，预先加载所有要使用的资源然后再开始绘制。以上，就是canvas动画主要的实现原理。如果想要我们的动画在不同方向上再进行移动，即我们只要不断更改我们绘制坐标位置即可。 拓展阅读1：canvas动画优化小议 拓展阅读2：提高 HTML5 画布性能 拓展阅读里面提到我们对动画可以分层，让不同频率的动画绘制在不同的图层上，同时我们对这一次图层的变化与上一次图层的内容进行对比，找出变化的区域，这也是我们称为的脏区域，这样只要更新脏区域的内容，就能提升canvas的性能了。 ​ RequestAnimationFrame 与setInterval setTimeout 区别我们以前做动画的时候，都知道要动画流畅，需要让页面1s渲染60帧，所以我们的时间间隔会设置为1/60*1000 = 16 ms 。再后来看到的文章都指出，动画不要使用setInterval或者setTimeout 去实现我们想要的效果，而应该使用RAF,那RAF和setTimeout 与 setInterval的区别到底在哪里？ RequestAnimationFrame 与setInterval setTimeout 区别 setInterval和setTimeout 在非当前窗口，或者浏览器‘休眠’的时候，即使渲染停止了，但是计时器不会休息，仍然会顽强的跑着！这样会加大浏览器的负担影响页面性能。 第二个不同在于callback队列的不同： 我们假设这里有3个循环计数器的实现，A是利用RAF的递归调用做的，B是用setInterval + 16ms做的，C是用setTimeout + 16ms + 递归调用实现的。然后用这3个计步器来做一个callback的循环调用。同时假设这个callback执行消耗的时间固定为100ms。那么我们可以大致猜想一下 B在做这件事情的具体过程：B从时间零点开始第一次执行callback，16ms之后发现应该执行第二次了，但是发现第一次还没做完，于是还是得继续第一次没做完的事情，把第二次callback排到自己的一个计划队列里面，等到第一次执行完了再执行队列里的第二次…但是恶性循环，32ms之后，第一次的事情还没做完，第3次的任务又来了。。。于是，这个任务队列越来越长，越来越长。。。而对于A而言每一次任务的完成仍然需要100ms，但是浏览器不会在A没有完成当前任务的时候给它下一次的任务。也就是说A总是花100ms完成一次任务，然后再花100ms完成下一次任务。 结论：A完成10此任务的时间应该是1000ms，但是B和C完成10次任务的总时间应该需要&gt;=1000ms，因为他们还要分心去管理他们的任务队列 关于FramePerSecond和deltaTime FPS: Frame Per Second 1s的帧数 dt: Delta Time 1帧与1帧之间的时间间隔 结论： 理论上 1s/FPS = dt 123456789var start = (+new Date), dt, now;(function loop()&#123; requestAnimationFrame(function()&#123; now = (+new Date); dt = now - start; start = now; &#125;); &#125;)(); 通过FPS与dt可以用来反映动画的流畅程度，那对于程序而言dt 可以干什么呢？ 程序里dt(deltaTime)的作用？dt 在我们控制物体移动时有巨大的作用，举个例子： 假设我们在性能好的机器和性能差一些的机器上同时测试一个游戏。好的机器的FPS稳定在60，差的机器FPS稳定在30。就像上面Canvas实现的bird动画里面，我们在每帧的update如果都给它的纵向移动距离+1 12&gt; bird.y +=1&gt; &gt; 那么在性能好的机子上，1s可以达到60帧，60帧以后bird纵向距离移动了60；但是在差的机子上，1s可能只有30帧，30帧以后bird纵向距离移动了30，这显然并不科学！ 所以我们只要 12&gt; bird.y += dt*60&gt; &gt; 性能好的机子上dt = 1/60 性能差的机子上dt = 1/30 ，性能好的机子上每帧移动1，性能差的机子上每帧移动2，这样最后的位置是一致的","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://motionvisions.github.io/categories/技术文章/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://motionvisions.github.io/tags/canvas/"}]},{"title":"CSS 3D实现虚拟全景探究","slug":"CSS 3D实现虚拟全景探究","date":"2016-11-27T16:00:00.000Z","updated":"2016-12-09T09:42:42.000Z","comments":true,"path":"2016/11/28/CSS 3D实现虚拟全景探究/","link":"","permalink":"https://motionvisions.github.io/2016/11/28/CSS 3D实现虚拟全景探究/","excerpt":"","text":"随着移动设备的发展，手机浏览器的兼容性已经变得比较令人满意，绝大部分CSS3属性和HTML5 API已经被移动浏览器支持。今年淘宝造物节的H5活动宣传页实现的3D虚拟全景令人感到惊艳。本文就是来探究如何利用CSS3 和 HTML5 API来实现一个基于浏览器的虚拟全景。 几个例子话不多说，先上例子。 第一个就是2016年的淘宝造物节。 第二个是腾讯在2014年世界互联网大会上制作的公司介绍页。 核心技术主要的核心技术包括CSS3几个有关2D/3D变换的属性和HTML5设备陀螺仪API。 2D平面上的变换在2D平面实现伪3D效果主要利用到了transform中的rotateX, rotateY, rotateZ三个属性。通过这三个属性可以模拟人眼在与屏幕平行位置移动时观察屏幕内物体的视觉效果。假设屏幕里有一个正方形。那么可以通过rotateX来模拟人上下移动时观察物体的效果；通过rotateY来模拟人左右移动时观察物体的效果；通过rotateZ来模拟人在倾斜时（比如扭头）观察物体的效果.具体效果如下所示。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"https://motionvisions.github.io/categories/技术文章/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://motionvisions.github.io/tags/CSS3/"},{"name":"3D","slug":"3D","permalink":"https://motionvisions.github.io/tags/3D/"}]}]}